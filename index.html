    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            margin: 0;
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(0, 150, 255, 0.3);
            background: #111;
            max-width: 100%;
            max-height: 100%;
            transition: transform 0.05s ease-in-out;
        }
        canvas {
            background: transparent;
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            text-align: center;
            z-index: 10;
            padding: 15px;
        }
        .hidden {
            display: none;
        }
        button {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            padding: 14px 28px;
            margin: 15px;
            cursor: pointer;
            font-size: 18px;
            border-radius: 8px;
            transition: background 0.3s, transform 0.1s, box-shadow 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1.5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        button:hover {
            background: linear-gradient(145deg, #5cc060, #43a047);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.5);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 20px;
            box-sizing: border-box;
            z-index: 5;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none;
            font-size: 1.1em;
            text-shadow: 0 1px 3px rgba(0,0,0,0.7);
        }
        .hud-left {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }
        .score-area {
             display: flex;
             gap: 15px;
        }
        .score-item, .level-item, .combo-item {
             background: rgba(255, 255, 255, 0.1);
             padding: 5px 10px;
             border-radius: 5px;
             font-size: 0.9em;
             white-space: nowrap;
        }
        .combo-item {
            background: rgba(255, 152, 0, 0.2);
            color: #ffcc80;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .combo-item.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .lives-area {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .lives-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .life-icon {
            width: 18px;
            height: 18px;
            background: #ff4444;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        .life-icon.lost {
            transform: scale(0);
            opacity: 0;
        }
        #overlay-content {
            max-width: 95%;
            max-height: 90%;
            overflow-y: auto;
            padding: 25px;
            background: rgba(10, 10, 20, 0.85);
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 150, 255, 0.3);
            border: 1px solid rgba(0, 150, 255, 0.2);
        }
        .intro-content {
            padding: 20px;
        }
        .powerup-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
            gap: 15px;
        }
        .powerup-item {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 25px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s, background 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .powerup-item:hover {
            transform: scale(1.08);
            background: rgba(255, 255, 255, 0.2);
        }
        .powerup-color {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 0 10px currentColor;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .game-title {
            font-size: 3em;
            margin: 0 0 20px 0;
            text-shadow: 0 0 15px rgba(76, 175, 80, 1);
            color: #66bb6a;
            font-weight: bold;
        }
        .level-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 3.5em;
            font-weight: bold;
            color: #ffdd57;
            text-shadow: 0 0 15px rgba(255, 221, 87, 1);
            opacity: 0;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            pointer-events: none;
            z-index: 20;
        }
        .level-alert.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            animation: pulse-level 1.5s infinite alternate;
        }
        @keyframes pulse-level {
            0% { transform: translate(-50%, -50%) scale(1); text-shadow: 0 0 15px rgba(255, 221, 87, 1); }
            100% { transform: translate(-50%, -50%) scale(1.15); text-shadow: 0 0 25px rgba(255, 221, 87, 1); }
        }
        #loading-progress {
            width: 80%;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-top: 25px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A, #aed581);
            border-radius: 12px;
            transition: width 0.4s ease-out;
        }
        #active-powerups {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 6;
            pointer-events: none;
        }
        .powerup-indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-size: 60%;
            background-position: center;
            background-repeat: no-repeat;
            border: 2px solid white;
            box-shadow: 0 0 10px currentColor;
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.3s, transform 0.3s;
        }
        .powerup-indicator.active {
            opacity: 0.9;
            transform: scale(1);
        }
        #near-miss-text {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            font-weight: bold;
            color: #ff9800;
            text-shadow: 0 0 8px rgba(255, 152, 0, 0.8);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
            z-index: 20;
            animation: nearMissPulse 0.5s ease-out;
        }
        #near-miss-text.visible {
            opacity: 1;
            transform: translate(-50%, -80px);
        }
        @keyframes nearMissPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -80px) scale(1); }
        }
        @media (max-width: 768px) {
            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }
            html {
                height: -webkit-fill-available;
            }
            .game-title {
                font-size: 2em;
            }
            #overlay-content {
                padding: 15px;
            }
            .powerup-list {
                gap: 8px;
            }
            .powerup-item {
                padding: 8px 12px;
                font-size: 0.9em;
            }
            .powerup-color {
                width: 18px;
                height: 18px;
            }
            button {
                padding: 12px 24px;
                font-size: 16px;
            }
            #hud {
                padding: 10px 15px;
                font-size: 1em;
                align-items: center;
            }
             .hud-left {
                 gap: 3px;
             }
             .score-item, .level-item, .combo-item, .lives-area {
                 font-size: 0.85em;
                 padding: 4px 8px;
             }
            .life-icon {
                width: 16px;
                height: 16px;
            }
            .level-alert {
                font-size: 2.5em;
            }
             #active-powerups {
                bottom: 5px;
                gap: 5px;
            }
            .powerup-indicator {
                width: 25px;
                height: 25px;
            }
        }
         @media (max-width: 480px) {
             .game-title {
                font-size: 1.8em;
            }
             button {
                padding: 10px 20px;
                font-size: 14px;
            }
             #hud {
                 padding: 8px 10px;
                 flex-wrap: wrap;
                 justify-content: flex-start;
                 gap: 5px;
             }
             .hud-left {
                 width: 100%;
                 flex-direction: row;
                 justify-content: space-between;
                 margin-bottom: 5px;
             }
              .lives-area {
             }
             .score-item, .level-item, .combo-item, .lives-area {
                 font-size: 0.8em;
                 padding: 3px 6px;
             }
             .life-icon {
                 width: 14px;
                 height: 14px;
             }
         }
    </style>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud" class="hidden">
            <div class="hud-left">
                 <div class="score-area">
                    <div class="score-item">Score: <span id="score">0</span></div>
                    <div class="level-item">Level: <span id="level">1</span></div>
                 </div>
                 <div id="combo-display" class="combo-item">Combo: <span id="combo-counter">0</span>x</div>
            </div>
            <div class="lives-area">
                Lives: <div id="lives-container" class="lives-container"></div>
            </div>
        </div>
        <div id="level-alert" class="level-alert">LEVEL <span id="level-number">1</span>!</div>
        <div id="near-miss-text" class="near-miss-text">NEAR MISS!</div>
        <div id="loading-screen" class="overlay">
            <h2>Loading Game Assets</h2>
            <div id="loading-progress">
                <div id="loading-bar"></div>
            </div>
             <p style="margin-top: 15px;">Please wait...</p>
        </div>
        <div id="intro-screen" class="overlay hidden">
            <div id="overlay-content" class="intro-content">
                <h1 class="game-title">Enhanced Racer</h1>
                <p>Navigate through obstacles, collect power-ups, and aim for the high score!</p>
                <h3>Controls:</h3>
                <p>⬅️ Left / A | ➡️ Right / D</p>
                <p>Mobile: Touch Left/Right side</p>
                <h3>Power-ups:</h3>
                <div class="powerup-list">
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #3f3; color: #3f3;"></div>
                        <span>Shield</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #39f; color: #39f;"></div>
                        <span>Speed Boost</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #fc0; color: #fc0;"></div>
                        <span>Score Boost</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #f33; color: #f33;"></div>
                        <span>Extra Life</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #c3f; color: #c3f;"></div>
                        <span>Magnet</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #f90; color: #f90;"></div>
                        <span>Clear Path</span>
                    </div>
                    <div class="powerup-item">
                        <div class="powerup-color" style="background: #aaa; color: #aaa;"></div>
                        <span>Slow Motion</span>
                    </div>
                </div>
                 <h3>Obstacles:</h3>
                <p>Rocks, Cones, Oil Slicks, Sweepers, <span style="color:#663300; font-weight:bold;">Potholes</span> (Slow Down)</p>
                <button id="start-button">Start Game</button>
                <p style="margin-top: 15px; font-size: 0.9em;">High Score: <span id="intro-high-score">0</span></p>
            </div>
        </div>
        <div id="game-over-screen" class="overlay hidden">
            <div id="overlay-content">
                <h2>Game Over</h2>
                <p style="font-size: 1.2em;">Your score: <span id="final-score">0</span></p>
                <p id="high-score-message" class="hidden" style="color: gold; text-shadow: 0 0 10px gold; font-weight: bold; margin: 10px 0;">New High Score!</p>
                <p style="font-size: 1.1em;">Highest Score: <span id="game-over-high-score">0</span></p>
                <button id="restart-button">Play Again</button>
            </div>
        </div>
        <div id="active-powerups">
            <div id="shield-indicator" class="powerup-indicator" style="background-color: #3f3; color: #3f3;"></div>
            <div id="speed-indicator" class="powerup-indicator" style="background-color: #39f; color: #39f;"></div>
            <div id="magnet-indicator" class="powerup-indicator" style="background-color: #c3f; color: #c3f;"></div>
            <div id="slowmo-indicator" class="powerup-indicator" style="background-color: #aaa; color: #aaa;"></div>
        </div>
    </div>
    <script>
    (() => {
        const GAME_CONFIG = {
            TARGET_FPS: 60,
            BASE_WIDTH: 800,
            BASE_HEIGHT: 600,
            LEVEL_UP_SCORE: 2500,
            INITIAL_LIVES: 3,
            MAX_LIVES: 5,
            BASE_SPEED: 4.5,
            SPEED_INCREMENT_PER_LEVEL: 0.4,
            OBSTACLE_BASE_SPAWN_RATE: 100,
            OBSTACLE_SPAWN_RATE_LEVEL_MOD: 6,
            POWERUP_SPAWN_RATE: 180,
            POWERUP_SPAWN_CHANCE: 0.6,
            NEAR_MISS_DISTANCE: 25,
            NEAR_MISS_SCORE: 50,
            OIL_SLICK_DURATION: 150,
            OIL_SLICK_SPEED_MULTIPLIER: 0.4,
            POTHOLE_DURATION: 90,
            POTHOLE_SPEED_MULTIPLIER: 0.7,
            SLOW_MOTION_DURATION: 240,
            SLOW_MOTION_MULTIPLIER: 0.5,
            INVINCIBILITY_DURATION: 100,
            MAGNET_RADIUS: 180,
            PARTICLE_COUNT_COLLISION: 35,
            PARTICLE_COUNT_POWERUP: 25,
            PARTICLE_COUNT_LEVELUP: 60,
            PARTICLE_COUNT_EXHAUST: 2,
            SCREEN_SHAKE_DURATION: 15,
            SCREEN_SHAKE_MAGNITUDE: 5,
            COMBO_DURATION: 120,
            COMBO_SCORE_BONUS: 100,
            RAIN_DROP_COUNT: 70,
        };
        const TRACK_CONFIG = {
            WIDTH_RATIO: 0.45,
            DEFAULT_COLOR: '#282828',
            LINE_WIDTH_RATIO: 0.015,
            LINE_HEIGHT_RATIO: 0.07,
            LINE_GAP_RATIO: 0.05,
            DEFAULT_EDGE_COLOR: '#444',
            EDGE_WIDTH: 5,
            DEFAULT_LINE_COLOR: '#aaaaaa',
        };
        const LEVEL_THEMES = [
            { bg: ['#0f172a', '#1e293b'], track: '#282828', edge: '#444', line: '#aaaaaa' },
            { bg: ['#2a0f1e', '#3b1e29'], track: '#382828', edge: '#554444', line: '#bb9999' },
            { bg: ['#0f2a17', '#1e3b29'], track: '#283828', edge: '#445544', line: '#99bb99' },
            { bg: ['#2a2a0f', '#3b3b1e'], track: '#383828', edge: '#555544', line: '#bbbb99' },
            { bg: ['#1a0f2a', '#291e3b'], track: '#282838', edge: '#444455', line: '#9999bb' },
        ];
        const CAR_CONFIG = {
            WIDTH_RATIO: 0.075,
            HEIGHT_RATIO: 0.15,
            LATERAL_SPEED_RATIO: 0.01,
            HITBOX_SCALE: { width: 0.7, height: 0.8 },
            TIRE_MARK_INTERVAL: 5,
            TIRE_MARK_LIFE: 40,
            EXHAUST_OFFSET_Y: 0.5,
            EXHAUST_OFFSET_X: 0.2,
        };
        const OBSTACLE_TYPES = {
            rock: { widthRatio: 0.06, heightRatio: 0.08, fatal: true, color: '#a0522d', imgKey: 'rock' },
            cone: { widthRatio: 0.05, heightRatio: 0.08, fatal: true, color: '#ff4500', imgKey: 'cone' },
            oilSlick: { widthRatio: 0.08, heightRatio: 0.05, fatal: false, color: '#1a1a1a', imgKey: 'oilSlick', opacity: 0.7, effect: 'oilSlick' },
            sweeper: { widthRatio: 0.15, heightRatio: 0.03, fatal: true, color: '#cc0000', imgKey: null, speedX: 2.5 },
            pothole: { widthRatio: 0.07, heightRatio: 0.04, fatal: false, color: '#4d2600', imgKey: null, effect: 'pothole' }
        };
        const POWERUP_TYPES = {
            shield: { color: '#3f3', glow: 'rgba(0, 255, 0, 0.7)', duration: 300, icon: 'shield' },
            speedBoost: { color: '#39f', glow: 'rgba(51, 153, 255, 0.7)', duration: 240, icon: 'speed' },
            scoreBoost: { color: '#fc0', glow: 'rgba(255, 204, 0, 0.7)', score: 500, icon: 'score' },
            extraLife: { color: '#f33', glow: 'rgba(255, 51, 51, 0.7)', icon: 'life' },
            magnet: { color: '#c3f', glow: 'rgba(204, 51, 255, 0.7)', duration: 300, icon: 'magnet' },
            clearPath: { color: '#f90', glow: 'rgba(255, 153, 0, 0.7)', icon: 'clear' },
            slowMotion: { color: '#aaa', glow: 'rgba(180, 180, 180, 0.7)', duration: GAME_CONFIG.SLOW_MOTION_DURATION, icon: 'slowmo' }
        };
        const POWERUP_SIZE_RATIO = 0.045;
        const GAME = {
            canvas: null,
            ctx: null,
            width: GAME_CONFIG.BASE_WIDTH,
            height: GAME_CONFIG.BASE_HEIGHT,
            scaleFactor: 1,
            lastTime: 0,
            frameTime: 1,
            animId: null,
            state: 'loading',
            score: 0,
            highScore: 0,
            level: 1,
            lives: GAME_CONFIG.INITIAL_LIVES,
            gameSpeed: GAME_CONFIG.BASE_SPEED,
            baseGameSpeed: GAME_CONFIG.BASE_SPEED,
            isPaused: false,
            screenShakeTimer: 0,
            screenShakeMagnitude: 0,
            comboCounter: 0,
            comboTimer: 0,
            currentTheme: LEVEL_THEMES[0],
            isSlowMotionActive: false,
            slowMotionTimer: 0,
            potholeTimer: 0,
        };
        const TRACK = {
            x: 0,
            width: 0,
            lines: [],
            lineWidth: 0,
            lineHeight: 0,
            lineGap: 0,
        };
        const CAR = {
            x: 0, y: 0, width: 0, height: 0,
            targetX: 0,
            lateralSpeed: 0,
            isMovingLeft: false, isMovingRight: false,
            isShielded: false, shieldTimer: 0,
            hasMagnet: false, magnetTimer: 0,
            speedBoostActive: false, speedBoostTimer: 0,
            invincibilityTimer: 0,
            tireMarkTimer: 0,
            exhaustTimer: 0,
        };
        let obstacles = [];
        let powerUps = [];
        let particles = [];
        let tireMarks = [];
        let backgroundStars = [];
        let rainDrops = [];
        let obstacleTimer = 0;
        let powerUpTimer = 0;
        let oilSlickTimer = 0;
        let levelAlertTimer = 0;
        let nearMissTimer = 0;
        const ASSETS = {
            images: {
                car: 'https://static.wixstatic.com/media/3d9313_1678469d0125461891b455d5b8a1f843~mv2.png',
                rock: 'https://static.wixstatic.com/media/3d9313_019516d93a18420fa62bd70562629378~mv2.png',
                cone: 'https://static.wixstatic.com/media/3d9313_091ec41c18fd4f4f9588a347ae1d00dd~mv2.png',
                oilSlick: 'https://static.wixstatic.com/media/3d9313_8c24876ed6cb4585981d6cb07021a995~mv2.png'
            },
            loaded: {},
            count: 0,
            total: 0,
            errorCount: 0,
        };
        const DOM = {
            container: null, canvas: null,
            hud: { container: null, score: null, level: null, livesContainer: null, comboDisplay: null, comboCounter: null },
            screens: { loading: null, intro: null, gameOver: null },
            buttons: { start: null, restart: null },
            loadingBar: null,
            finalScore: null, highScoreMsg: null, gameOverHighScore: null, introHighScore: null,
            levelAlert: null, levelNumber: null, nearMissText: null,
            powerupIndicators: { shield: null, speed: null, magnet: null, slowmo: null }
        };
        function init() {
            console.log("Initializing game v4...");
            cacheDOM();
            setupCanvas();
            loadHighScore();
            updateIntroHighScore();
            setupEventListeners();
            loadAssets(() => {
                console.log("Assets loaded.");
                showScreen('intro');
                createBackgroundStars();
                createRainDrops();
                resizeGame();
            });
        }
        function cacheDOM() {
            DOM.container = document.getElementById('game-container');
            DOM.canvas = document.getElementById('game-canvas');
            DOM.hud.container = document.getElementById('hud');
            DOM.hud.score = document.getElementById('score');
            DOM.hud.level = document.getElementById('level');
            DOM.hud.livesContainer = document.getElementById('lives-container');
            DOM.hud.comboDisplay = document.getElementById('combo-display');
            DOM.hud.comboCounter = document.getElementById('combo-counter');
            DOM.screens.loading = document.getElementById('loading-screen');
            DOM.screens.intro = document.getElementById('intro-screen');
            DOM.screens.gameOver = document.getElementById('game-over-screen');
            DOM.buttons.start = document.getElementById('start-button');
            DOM.buttons.restart = document.getElementById('restart-button');
            DOM.loadingBar = document.getElementById('loading-bar');
            DOM.finalScore = document.getElementById('final-score');
            DOM.highScoreMsg = document.getElementById('high-score-message');
            DOM.gameOverHighScore = document.getElementById('game-over-high-score');
            DOM.introHighScore = document.getElementById('intro-high-score');
            DOM.levelAlert = document.getElementById('level-alert');
            DOM.levelNumber = document.getElementById('level-number');
            DOM.nearMissText = document.getElementById('near-miss-text');
            DOM.powerupIndicators.shield = document.getElementById('shield-indicator');
            DOM.powerupIndicators.speed = document.getElementById('speed-indicator');
            DOM.powerupIndicators.magnet = document.getElementById('magnet-indicator');
            DOM.powerupIndicators.slowmo = document.getElementById('slowmo-indicator');
        }
        function setupCanvas() {
            GAME.canvas = DOM.canvas;
            GAME.ctx = GAME.canvas.getContext('2d');
            GAME.canvas.width = GAME_CONFIG.BASE_WIDTH;
            GAME.canvas.height = GAME_CONFIG.BASE_HEIGHT;
        }
        function loadHighScore() {
            try {
                const storedScore = localStorage.getItem('enhancedCarRacerHighScore_v4');
                if (storedScore) {
                    GAME.highScore = parseInt(storedScore) || 0;
                }
                console.log("Loaded high score:", GAME.highScore);
            } catch (e) {
                console.warn('LocalStorage not available or accessible.');
                GAME.highScore = 0;
            }
        }
        function saveHighScore() {
             const storedHighScore = parseInt(localStorage.getItem('enhancedCarRacerHighScore_v4') || '0');
             if (GAME.score <= storedHighScore) return;
            GAME.highScore = GAME.score;
            try {
                localStorage.setItem('enhancedCarRacerHighScore_v4', GAME.highScore.toString());
                console.log("Saved new high score:", GAME.highScore);
            } catch (e) {
                console.warn('LocalStorage not available or accessible for saving.');
            }
        }
        function updateIntroHighScore() {
             const storedHighScore = parseInt(localStorage.getItem('enhancedCarRacerHighScore_v4') || '0');
             GAME.highScore = Math.max(GAME.highScore, storedHighScore);
            DOM.introHighScore.textContent = GAME.highScore;
        }
        function setupEventListeners() {
            window.addEventListener('resize', resizeGame);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            GAME.canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            GAME.canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            GAME.canvas.addEventListener('touchend', handleTouchEnd);
            GAME.canvas.addEventListener('touchcancel', handleTouchEnd);
            DOM.buttons.start.addEventListener('click', startGame);
            DOM.buttons.restart.addEventListener('click', restartGame);
             DOM.container.addEventListener('touchmove', (e) => {
                 if (GAME.state === 'playing') e.preventDefault();
             }, { passive: false });
        }
        function loadAssets(callback) {
            ASSETS.total = Object.keys(ASSETS.images).length;
            ASSETS.count = 0;
            ASSETS.errorCount = 0;
            if (ASSETS.total === 0) {
                console.log("No image assets to load.");
                updateLoadingProgress();
                callback();
                return;
            }
            console.log(`Loading ${ASSETS.total} assets...`);
            for (const key in ASSETS.images) {
                const img = new Image();
                img.src = ASSETS.images[key];
                img.onload = () => {
                    ASSETS.loaded[key] = img;
                    ASSETS.count++;
                    updateLoadingProgress();
                    if (ASSETS.count + ASSETS.errorCount === ASSETS.total) callback();
                };
                img.onerror = () => {
                    console.error(`Failed to load image: ${key} at ${ASSETS.images[key]}`);
                    ASSETS.errorCount++;
                    updateLoadingProgress();
                    if (ASSETS.count + ASSETS.errorCount === ASSETS.total) callback();
                };
            }
        }
        function updateLoadingProgress() {
            const progress = ASSETS.total === 0 ? 100 : Math.floor(((ASSETS.count + ASSETS.errorCount) / ASSETS.total) * 100);
            DOM.loadingBar.style.width = `${progress}%`;
        }
        function startGame() {
            console.log("Starting game...");
            resetGame();
            showLevelAlert();
            showScreen('playing');
            GAME.lastTime = performance.now();
            if (GAME.animId) cancelAnimationFrame(GAME.animId);
            GAME.animId = requestAnimationFrame(gameLoop);
        }
        function restartGame() {
            console.log("Restarting game...");
            startGame();
        }
        function gameOver() {
            console.log("Game Over. Score:", GAME.score);
            GAME.state = 'gameOver';
            endCombo();
            const oldHighScore = parseInt(localStorage.getItem('enhancedCarRacerHighScore_v4') || '0');
            const isNewHighScore = GAME.score > oldHighScore;
            if (isNewHighScore) {
                 saveHighScore();
                 DOM.highScoreMsg.classList.remove('hidden');
            } else {
                 DOM.highScoreMsg.classList.add('hidden');
            }
            DOM.finalScore.textContent = GAME.score;
            DOM.gameOverHighScore.textContent = Math.max(GAME.score, oldHighScore);
            showScreen('gameOver');
            updateIntroHighScore();
        }
        function resetGame() {
            GAME.score = 0;
            GAME.level = 1;
            GAME.lives = GAME_CONFIG.INITIAL_LIVES;
            GAME.baseGameSpeed = GAME_CONFIG.BASE_SPEED;
            GAME.gameSpeed = GAME.baseGameSpeed;
            GAME.currentTheme = LEVEL_THEMES[0];
            GAME.screenShakeTimer = 0;
            GAME.comboCounter = 0;
            GAME.comboTimer = 0;
            GAME.isSlowMotionActive = false;
            GAME.slowMotionTimer = 0;
            GAME.potholeTimer = 0;
            CAR.x = TRACK.x + TRACK.width / 2;
            CAR.targetX = CAR.x;
            CAR.y = GAME.height - CAR.height * 1.0;
            CAR.isShielded = false; CAR.shieldTimer = 0;
            CAR.hasMagnet = false; CAR.magnetTimer = 0;
            CAR.speedBoostActive = false; CAR.speedBoostTimer = 0;
            CAR.invincibilityTimer = 0;
            CAR.tireMarkTimer = 0;
            CAR.exhaustTimer = 0;
            obstacles = [];
            powerUps = [];
            particles = [];
            tireMarks = [];
            obstacleTimer = 0;
            powerUpTimer = 0;
            oilSlickTimer = 0;
            levelAlertTimer = 0;
            nearMissTimer = 0;
            updateHUD();
            updateLivesDisplay(true);
            updatePowerupIndicators();
            updateComboDisplay();
        }
        function gameLoop(timestamp) {
            if (GAME.state !== 'playing' || GAME.isPaused) {
                 if (GAME.state === 'playing' && GAME.isPaused) {
                     GAME.lastTime = performance.now();
                 }
                GAME.animId = requestAnimationFrame(gameLoop);
                return;
            }
            const currentTime = performance.now();
            const deltaTime = currentTime - GAME.lastTime;
            GAME.lastTime = currentTime;
            const maxDeltaTime = 1000 / (GAME_CONFIG.TARGET_FPS / 3);
            const clampedDeltaTime = Math.min(deltaTime, maxDeltaTime);
            GAME.frameTime = clampedDeltaTime / (1000 / GAME_CONFIG.TARGET_FPS);
            update();
            draw();
            GAME.animId = requestAnimationFrame(gameLoop);
        }
        function update() {
            updateTimers();
            updateGameSpeed();
            updateScoreAndLevel();
            updateCar();
            updateTrackLines();
            updateObstacles();
            updatePowerUps();
            updateParticles();
            updateTireMarks();
            updateBackgroundStars();
            updateRainDrops();
            spawnObjects();
            checkCollisions();
            updateHUD();
            updatePowerupIndicators();
            updateCombo();
        }
        function updateTimers() {
            const ft = GAME.frameTime;
            if (levelAlertTimer > 0) levelAlertTimer -= ft;
            if (nearMissTimer > 0) nearMissTimer -= ft;
            if (CAR.shieldTimer > 0) CAR.shieldTimer -= ft; else CAR.isShielded = false;
            if (CAR.magnetTimer > 0) CAR.magnetTimer -= ft; else CAR.hasMagnet = false;
            if (CAR.speedBoostTimer > 0) CAR.speedBoostTimer -= ft; else CAR.speedBoostActive = false;
            if (CAR.invincibilityTimer > 0) CAR.invincibilityTimer -= ft;
            if (oilSlickTimer > 0) oilSlickTimer -= ft;
            if (GAME.potholeTimer > 0) GAME.potholeTimer -= ft;
            if (GAME.slowMotionTimer > 0) GAME.slowMotionTimer -= ft; else GAME.isSlowMotionActive = false;
            if (GAME.screenShakeTimer > 0) GAME.screenShakeTimer -= ft;
            if (GAME.comboTimer > 0) GAME.comboTimer -= ft; else endCombo();
            if (levelAlertTimer <= 0) DOM.levelAlert.classList.remove('visible');
            if (nearMissTimer <= 0) DOM.nearMissText.classList.remove('visible');
        }
        function updateGameSpeed() {
            let speedMultiplier = 1.0;
            if (GAME.isSlowMotionActive) {
                speedMultiplier *= GAME_CONFIG.SLOW_MOTION_MULTIPLIER;
            } else if (CAR.speedBoostActive) {
                speedMultiplier *= 1.5;
            }
            if (oilSlickTimer > 0) {
                speedMultiplier *= GAME_CONFIG.OIL_SLICK_SPEED_MULTIPLIER;
            } else if (GAME.potholeTimer > 0) {
                speedMultiplier *= GAME_CONFIG.POTHOLE_SPEED_MULTIPLIER;
            }
            GAME.gameSpeed = GAME.baseGameSpeed * speedMultiplier;
        }
         function updateScoreAndLevel() {
            GAME.score += Math.ceil(GAME.baseGameSpeed * 0.2 * GAME.level * GAME.frameTime);
            if (GAME.score >= GAME.level * GAME_CONFIG.LEVEL_UP_SCORE) {
                levelUp();
            }
        }
        function levelUp() {
            GAME.level++;
            const themeIndex = Math.floor((GAME.level - 1) / 3) % LEVEL_THEMES.length;
            GAME.currentTheme = LEVEL_THEMES[themeIndex];
            GAME.baseGameSpeed = GAME_CONFIG.BASE_SPEED + (GAME.level - 1) * GAME_CONFIG.SPEED_INCREMENT_PER_LEVEL;
            createParticles(GAME.width / 2, GAME.height / 2, GAME_CONFIG.PARTICLE_COUNT_LEVELUP, '#ffdd57', 6);
            showLevelAlert();
            console.log(`Level Up! Reached Level ${GAME.level}. Base Speed: ${GAME.baseGameSpeed.toFixed(2)}. Theme: ${themeIndex}`);
        }
        function updateCar() {
            const ft = GAME.frameTime;
            let currentLateralSpeed = CAR.lateralSpeed;
            if (oilSlickTimer > 0) {
                currentLateralSpeed *= GAME_CONFIG.OIL_SLICK_SPEED_MULTIPLIER;
                CAR.targetX += (Math.random() - 0.5) * 10 * ft;
            } else if (GAME.potholeTimer > 0) {
                currentLateralSpeed *= GAME_CONFIG.POTHOLE_SPEED_MULTIPLIER;
            }

            if (CAR.isMovingLeft) CAR.targetX -= currentLateralSpeed * ft;
            if (CAR.isMovingRight) CAR.targetX += currentLateralSpeed * ft;

            const easingFactor = 0.25;
            CAR.x += (CAR.targetX - CAR.x) * easingFactor * ft;

            const carHalfWidth = CAR.width * CAR_CONFIG.HITBOX_SCALE.width / 2;
            const minX = TRACK.x + carHalfWidth;
            const maxX = TRACK.x + TRACK.width - carHalfWidth;
            CAR.targetX = Math.max(minX, Math.min(maxX, CAR.targetX));
            CAR.x = Math.max(minX, Math.min(maxX, CAR.x));

            CAR.tireMarkTimer -= ft;
            if (CAR.tireMarkTimer <= 0 && (Math.abs(CAR.x - CAR.targetX) > 1 || oilSlickTimer > 0 || GAME.potholeTimer > 0)) {
                 addTireMark(CAR.x - CAR.width * CAR_CONFIG.EXHAUST_OFFSET_X, CAR.y + CAR.height * CAR_CONFIG.EXHAUST_OFFSET_Y);
                 addTireMark(CAR.x + CAR.width * CAR_CONFIG.EXHAUST_OFFSET_X, CAR.y + CAR.height * CAR_CONFIG.EXHAUST_OFFSET_Y);
                 CAR.tireMarkTimer = CAR_CONFIG.TIRE_MARK_INTERVAL;
            }
            CAR.exhaustTimer -= ft;
            if (CAR.exhaustTimer <= 0) {
                 createExhaustParticles(CAR.x, CAR.y + CAR.height * CAR_CONFIG.EXHAUST_OFFSET_Y);
                 CAR.exhaustTimer = 3 + Math.random() * 3;
            }
        }
        function addTireMark(x, y) {
            tireMarks.push({ x: x, y: y, life: CAR_CONFIG.TIRE_MARK_LIFE, width: CAR.width * 0.1, height: CAR.height * 0.05 });
             if (tireMarks.length > 50) tireMarks.shift();
        }
        function createExhaustParticles(x, y) {
            const count = GAME_CONFIG.PARTICLE_COUNT_EXHAUST;
            for (let i = 0; i < count; i++) {
                const angle = Math.PI * 0.5 + (Math.random() - 0.5) * 0.5;
                const speed = 0.5 + Math.random() * 1;
                const size = Math.random() * 2 + 1;
                const life = 15 + Math.random() * 15;
                particles.push({
                    x: x + (Math.random() - 0.5) * CAR.width * 0.2,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed + GAME.gameSpeed * 0.5 * GAME.frameTime,
                    size: size,
                    color: `rgba(200, 200, 200, ${0.3 + Math.random() * 0.3})`,
                    life: life,
                    maxLife: life,
                    alpha: 1.0
                });
            }
        }
        function updateTireMarks() {
             for (let i = tireMarks.length - 1; i >= 0; i--) {
                const mark = tireMarks[i];
                mark.y += GAME.gameSpeed * GAME.frameTime;
                mark.life -= GAME.frameTime;
                if (mark.life <= 0 || mark.y > GAME.height) tireMarks.splice(i, 1);
            }
        }
        function updateTrackLines() {
            for (let i = 0; i < TRACK.lines.length; i++) {
                const line = TRACK.lines[i];
                line.y += GAME.gameSpeed * GAME.frameTime;
                if (line.y > GAME.height) {
                    let highestY = line.y;
                    for(let j=0; j<TRACK.lines.length; ++j) highestY = Math.min(highestY, TRACK.lines[j].y);
                    line.y = highestY - TRACK.lineHeight - TRACK.lineGap;
                }
            }
        }
        function updateObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += GAME.gameSpeed * GAME.frameTime;
                obs.rotation += (obs.rotationSpeed || 0) * GAME.frameTime;
                if (obs.type === 'sweeper') {
                     obs.x += obs.speedX * GAME.frameTime;
                     const margin = obs.width / 2;
                     const trackLeft = TRACK.x + margin;
                     const trackRight = TRACK.x + TRACK.width - margin;
                     if (obs.x <= trackLeft || obs.x >= trackRight) {
                         obs.speedX *= -1;
                         obs.x = Math.max(trackLeft, Math.min(trackRight, obs.x));
                     }
                }
                else if (GAME.level > 3 && obs.fatal && obs.moveDirection) {
                    obs.x += obs.moveDirection * GAME.frameTime * (GAME.level * 0.25);
                    const margin = obs.width / 2 + 10;
                    const trackLeft = TRACK.x + margin;
                    const trackRight = TRACK.x + TRACK.width - margin;
                    if (obs.x <= trackLeft || obs.x >= trackRight) {
                        obs.moveDirection *= -1;
                        obs.x = Math.max(trackLeft, Math.min(trackRight, obs.x));
                    }
                }
                if (obs.y - obs.height / 2 > GAME.height) obstacles.splice(i, 1);
            }
        }
        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                pu.y += GAME.gameSpeed * GAME.frameTime;
                pu.rotation += 0.03 * GAME.frameTime;
                pu.pulse = (pu.pulse || 0) + 0.06 * GAME.frameTime;
                if (CAR.hasMagnet) {
                    const puCenterX = pu.x;
                    const puCenterY = pu.y;
                    const dx = CAR.x - puCenterX;
                    const dy = CAR.y - puCenterY;
                    const distanceSq = dx * dx + dy * dy;
                    const magnetRadiusSq = GAME_CONFIG.MAGNET_RADIUS * GAME_CONFIG.MAGNET_RADIUS;
                    if (distanceSq < magnetRadiusSq) {
                        const distance = Math.sqrt(distanceSq);
                        const attractStrength = (1 - distance / GAME_CONFIG.MAGNET_RADIUS) * 20;
                        pu.x += (dx / distance) * attractStrength * GAME.frameTime;
                        pu.y += (dy / distance) * attractStrength * GAME.frameTime;
                    }
                }
                if (pu.y - pu.height / 2 > GAME.height) powerUps.splice(i, 1);
            }
        }
         function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * GAME.frameTime;
                if (!p.isText && !p.isExhaust) {
                    p.y += (p.vy + GAME.gameSpeed * 0.5) * GAME.frameTime;
                    p.vy += 0.1 * GAME.frameTime;
                } else {
                    p.y += p.vy * GAME.frameTime;
                     if (p.isExhaust) p.y += GAME.gameSpeed * 0.5 * GAME.frameTime;
                }
                p.life -= GAME.frameTime;
                p.alpha = Math.max(0, p.life / p.maxLife);
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        function createBackgroundStars() {
            if (backgroundStars.length > 0 && GAME.width === backgroundStars[0]?.gameWidth) return;
            backgroundStars = [];
             for (let i = 0; i < 100; i++) {
                backgroundStars.push({
                    x: Math.random() * GAME.width,
                    y: Math.random() * GAME.height,
                    size: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.5 + 0.2,
                    gameWidth: GAME.width
                });
            }
        }
        function updateBackgroundStars() {
            for (const star of backgroundStars) {
                star.y += star.speed * GAME.gameSpeed * 0.1 * GAME.frameTime;
                if (star.y > GAME.height) {
                    star.y = 0;
                    star.x = Math.random() * GAME.width;
                }
            }
        }
        function createRainDrops() {
             if (rainDrops.length > 0 && GAME.width === rainDrops[0]?.gameWidth) return;
             rainDrops = [];
             for (let i = 0; i < GAME_CONFIG.RAIN_DROP_COUNT; i++) {
                 rainDrops.push({
                     x: Math.random() * GAME.width,
                     y: Math.random() * GAME.height,
                     length: Math.random() * 10 + 5,
                     speed: Math.random() * 3 + 2,
                     gameWidth: GAME.width
                 });
             }
        }
        function updateRainDrops() {
             for (const drop of rainDrops) {
                 drop.y += drop.speed * GAME.gameSpeed * 0.8 * GAME.frameTime;
                 if (drop.y > GAME.height) {
                     drop.y = -drop.length;
                     drop.x = Math.random() * GAME.width;
                 }
             }
        }
        function spawnObjects() {
            const ft = GAME.frameTime;
            obstacleTimer += ft;
            powerUpTimer += ft;
            const obstacleSpawnThreshold = Math.max(25, GAME_CONFIG.OBSTACLE_BASE_SPAWN_RATE - GAME.level * GAME_CONFIG.OBSTACLE_SPAWN_RATE_LEVEL_MOD);
            if (obstacleTimer >= obstacleSpawnThreshold) {
                obstacleTimer = Math.random() * (obstacleSpawnThreshold * 0.3);
                if (obstacles.length < 4 + Math.floor(GAME.level / 1.5)) {
                    spawnObstacle();
                }
            }
            if (powerUpTimer >= GAME_CONFIG.POWERUP_SPAWN_RATE) {
                powerUpTimer = Math.random() * (GAME_CONFIG.POWERUP_SPAWN_RATE * 0.3);
                if (Math.random() < GAME_CONFIG.POWERUP_SPAWN_CHANCE && powerUps.length < 3) {
                    spawnPowerUp();
                }
            }
        }
        function spawnObstacle() {
            const types = Object.keys(OBSTACLE_TYPES);
            let typeKey;
            if (GAME.level > 4 && Math.random() < 0.15) {
                 typeKey = 'sweeper';
            } else {
                 const nonFatalChance = 0.3 + (GAME.level * 0.02);
                 const isFatal = Math.random() > nonFatalChance;
                 const possibleTypes = types.filter(t => t !== 'sweeper' && OBSTACLE_TYPES[t].fatal === isFatal);
                 if (possibleTypes.length > 0) {
                      typeKey = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
                 } else {
                      typeKey = isFatal ? 'rock' : (types.includes('pothole') ? 'pothole' : 'oilSlick');
                 }
            }
            const type = OBSTACLE_TYPES[typeKey];
            const width = type.widthRatio * GAME.width;
            const height = type.heightRatio * GAME.height;
            let spawnX;
            let attempts = 0;
            const avoidanceDist = width * 1.5;
            const checkY = height * 3;
            if (typeKey === 'sweeper') {
                 spawnX = (Math.random() < 0.5) ? TRACK.x + width/2 : TRACK.x + TRACK.width - width/2;
            } else {
                 do {
                     spawnX = TRACK.x + width/2 + Math.random() * (TRACK.width - width);
                     attempts++;
                     if (attempts > 10) break;
                 } while (
                     obstacles.some(obs => obs.y < checkY && Math.abs(obs.x - spawnX) < avoidanceDist) ||
                     powerUps.some(pu => pu.y < checkY && Math.abs(pu.x - spawnX) < avoidanceDist)
                 );
            }
            const newObstacle = {
                type: typeKey,
                x: spawnX,
                y: -height * (1 + Math.random() * 0.5),
                width: width,
                height: height,
                fatal: type.fatal,
                color: type.color,
                imgKey: type.imgKey,
                opacity: type.opacity || 1,
                rotation: (typeKey !== 'sweeper' && type.fatal) ? (Math.random() - 0.5) * 0.5 : 0,
                rotationSpeed: (typeKey !== 'sweeper' && type.fatal) ? (Math.random() - 0.5) * 0.03 : 0,
                moveDirection: (typeKey !== 'sweeper' && GAME.level > 3 && type.fatal && Math.random() < 0.4) ? (Math.random() > 0.5 ? 1 : -1) : 0,
                speedX: (typeKey === 'sweeper') ? (type.speedX * (spawnX < TRACK.x + TRACK.width / 2 ? 1 : -1)) : 0,
                effect: type.effect || null
            };
            obstacles.push(newObstacle);
        }
        function spawnPowerUp() {
            const types = Object.keys(POWERUP_TYPES);
            const typeKey = types[Math.floor(Math.random() * types.length)];
            const type = POWERUP_TYPES[typeKey];
            const size = POWERUP_SIZE_RATIO * GAME.width;
            let spawnX;
            let attempts = 0;
            const avoidanceDist = size * 2;
            const checkY = size * 3;
            do {
                spawnX = TRACK.x + size/2 + Math.random() * (TRACK.width - size);
                attempts++;
                if (attempts > 10) break;
            } while (
                 obstacles.some(obs => obs.y < checkY && Math.abs(obs.x - spawnX) < avoidanceDist) ||
                 powerUps.some(pu => pu.y < checkY && Math.abs(pu.x - spawnX) < avoidanceDist)
            );
            powerUps.push({
                type: typeKey, x: spawnX, y: -size * (1 + Math.random() * 0.5),
                width: size, height: size, color: type.color, glow: type.glow,
                icon: type.icon, rotation: 0, pulse: Math.random() * Math.PI
            });
        }
        function updateCombo() {
            if (GAME.comboCounter > 0 && GAME.comboTimer <= 0) {
                endCombo();
            }
            updateComboDisplay();
        }
        function incrementCombo() {
            GAME.comboCounter++;
            GAME.comboTimer = GAME_CONFIG.COMBO_DURATION;
            updateComboDisplay();
        }
        function endCombo() {
            if (GAME.comboCounter > 1) {
                const bonus = GAME.comboCounter * GAME_CONFIG.COMBO_SCORE_BONUS * GAME.level;
                GAME.score += bonus;
                console.log(`Combo End: ${GAME.comboCounter}x -> +${bonus} points`);
                 createFloatingText(`+${bonus} Combo!`, CAR.x, CAR.y - CAR.height, '#ffcc80', 60);
            }
            GAME.comboCounter = 0;
            GAME.comboTimer = 0;
            updateComboDisplay();
        }
        function updateComboDisplay() {
             if (GAME.comboCounter > 1) {
                 DOM.hud.comboCounter.textContent = GAME.comboCounter;
                 DOM.hud.comboDisplay.classList.add('visible');
             } else {
                 DOM.hud.comboDisplay.classList.remove('visible');
             }
        }
        function checkCollisions() {
             const carHitbox = {
                x: CAR.x - (CAR.width * CAR_CONFIG.HITBOX_SCALE.width / 2),
                y: CAR.y - (CAR.height * CAR_CONFIG.HITBOX_SCALE.height / 2),
                width: CAR.width * CAR_CONFIG.HITBOX_SCALE.width,
                height: CAR.height * CAR_CONFIG.HITBOX_SCALE.height
            };
             for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                const puHitbox = { x: pu.x - pu.width / 2, y: pu.y - pu.height / 2, width: pu.width, height: pu.height };
                if (rectCollision(carHitbox, puHitbox)) {
                    applyPowerUp(pu.type);
                    createParticles(pu.x, pu.y, GAME_CONFIG.PARTICLE_COUNT_POWERUP, pu.color, 3);
                    incrementCombo();
                    powerUps.splice(i, 1);
                }
            }
            if (CAR.invincibilityTimer > 0) return;
            let nearMissOccurredThisFrame = false;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                const obsHitbox = { x: obs.x - obs.width / 2, y: obs.y - obs.height / 2, width: obs.width, height: obs.height };
                if (rectCollision(carHitbox, obsHitbox)) {
                    handleObstacleCollision(obs, i);
                    if (obs.fatal && !CAR.isShielded) return;
                } else if (obs.fatal && !nearMissOccurredThisFrame) {
                    if (checkNearMiss(carHitbox, obsHitbox)) {
                        triggerNearMiss();
                        nearMissOccurredThisFrame = true;
                    }
                }
            }
        }
        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        function checkNearMiss(carRect, obsRect) {
            const verticalMargin = carRect.height * 0.5;
            const horizontalProximity = (carRect.x + carRect.width > obsRect.x - GAME_CONFIG.NEAR_MISS_DISTANCE && carRect.x < obsRect.x + obsRect.width + GAME_CONFIG.NEAR_MISS_DISTANCE);
            const verticalProximity = (carRect.y < obsRect.y + obsRect.height + verticalMargin && carRect.y + carRect.height > obsRect.y - verticalMargin);
            const carCenterY = carRect.y + carRect.height / 2;
            const obsCenterY = obsRect.y + obsRect.height / 2;
            const passedVertically = carCenterY < obsCenterY + obsRect.height * 0.3;
            return horizontalProximity && verticalProximity && passedVertically && nearMissTimer <= 0;
        }
        function triggerNearMiss() {
            GAME.score += GAME_CONFIG.NEAR_MISS_SCORE * GAME.level;
            DOM.nearMissText.classList.remove('visible');
            void DOM.nearMissText.offsetWidth;
            DOM.nearMissText.classList.add('visible');
            nearMissTimer = 45;
            incrementCombo();
        }
        function triggerScreenShake(magnitude, duration) {
             GAME.screenShakeMagnitude = magnitude;
             GAME.screenShakeTimer = duration;
        }
        function handleObstacleCollision(obs, index) {
            if (obs.fatal) {
                if (CAR.isShielded) {
                    CAR.isShielded = false;
                    CAR.shieldTimer = 0;
                    createParticles(CAR.x, CAR.y, GAME_CONFIG.PARTICLE_COUNT_POWERUP, '#0ff', 4);
                    if (obstacles[index] === obs) obstacles.splice(index, 1);
                } else {
                    if (CAR.invincibilityTimer <= 0) {
                        GAME.lives--;
                        triggerScreenShake(GAME_CONFIG.SCREEN_SHAKE_MAGNITUDE, GAME_CONFIG.SCREEN_SHAKE_DURATION);
                        createParticles(CAR.x, CAR.y, GAME_CONFIG.PARTICLE_COUNT_COLLISION, '#f50', 5);
                        endCombo();
                        updateLivesDisplay();
                        if (GAME.lives <= 0) {
                            setTimeout(gameOver, 50);
                        } else {
                            CAR.invincibilityTimer = GAME_CONFIG.INVINCIBILITY_DURATION;
                        }
                    }
                     if (GAME.lives > 0 && obstacles[index] === obs) {
                        obstacles.splice(index, 1);
                     }
                }
            } else if (obs.effect && CAR.invincibilityTimer <= 0) {
                 if (obs.effect === 'oilSlick') {
                     oilSlickTimer = GAME_CONFIG.OIL_SLICK_DURATION;
                     createParticles(obs.x, obs.y, 15, '#555', 3);
                 } else if (obs.effect === 'pothole') {
                     GAME.potholeTimer = GAME_CONFIG.POTHOLE_DURATION;
                     triggerScreenShake(GAME_CONFIG.SCREEN_SHAKE_MAGNITUDE * 0.5, GAME_CONFIG.SCREEN_SHAKE_DURATION * 0.5);
                     createParticles(obs.x, obs.y, 10, '#663300', 2);
                 }
                 if (obstacles[index] === obs) obstacles.splice(index, 1);
             } else if (!obs.fatal) {
                 if (obstacles[index] === obs) obstacles.splice(index, 1);
             }
        }
        function applyPowerUp(type) {
            const powerUp = POWERUP_TYPES[type];
            if (!powerUp) return;
            switch (type) {
                case 'shield':
                    CAR.isShielded = true; CAR.shieldTimer = powerUp.duration; CAR.invincibilityTimer = 0;
                    break;
                case 'speedBoost':
                    CAR.speedBoostActive = true; CAR.speedBoostTimer = powerUp.duration;
                    GAME.isSlowMotionActive = false; GAME.slowMotionTimer = 0;
                    break;
                case 'scoreBoost':
                    const scoreBonus = (powerUp.score || 500) * GAME.level;
                    GAME.score += scoreBonus;
                    createFloatingText(`+${scoreBonus}`, CAR.x, CAR.y, powerUp.color, 60);
                    break;
                case 'extraLife':
                    if (GAME.lives < GAME_CONFIG.MAX_LIVES) {
                        GAME.lives++; updateLivesDisplay();
                    } else {
                         const lifeBonus = 250 * GAME.level;
                         GAME.score += lifeBonus;
                         createFloatingText(`+${lifeBonus}`, CAR.x, CAR.y, '#fc0', 60);
                    }
                    break;
                case 'magnet':
                    CAR.hasMagnet = true; CAR.magnetTimer = powerUp.duration;
                    break;
                case 'clearPath':
                    let clearedCount = 0;
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        if (obs.fatal && obs.y < CAR.y + CAR.height/2 && obs.y > CAR.y - GAME.height * 0.8) {
                            createParticles(obs.x, obs.y, 15, '#f90', 4);
                            obstacles.splice(i, 1); clearedCount++;
                        }
                    }
                    break;
                case 'slowMotion':
                    GAME.isSlowMotionActive = true; GAME.slowMotionTimer = powerUp.duration;
                    CAR.speedBoostActive = false; CAR.speedBoostTimer = 0;
                    break;
            }
        }
        function createFloatingText(text, x, y, color, life) {
             particles.push({
                 x: x, y: y,
                 vx: (Math.random() - 0.5) * 0.5,
                 vy: -1.5,
                 size: 14,
                 color: color,
                 text: text,
                 life: life, maxLife: life, alpha: 1.0,
                 isText: true
             });
        }
        function draw() {
            const ctx = GAME.ctx;
            ctx.save();
            if (GAME.screenShakeTimer > 0) {
                const shakeX = (Math.random() - 0.5) * GAME.screenShakeMagnitude * (GAME.screenShakeTimer / GAME_CONFIG.SCREEN_SHAKE_DURATION);
                const shakeY = (Math.random() - 0.5) * GAME.screenShakeMagnitude * (GAME.screenShakeTimer / GAME_CONFIG.SCREEN_SHAKE_DURATION);
                ctx.translate(shakeX, shakeY);
                DOM.container.style.transform = `translate(${shakeX * 0.5}px, ${shakeY * 0.5}px)`;
            } else {
                DOM.container.style.transform = 'translate(0, 0)';
            }
            drawBackground(ctx);
            drawTrack(ctx);
            drawTireMarks(ctx);
            drawObstacles(ctx);
            drawPowerUps(ctx);
            drawCar(ctx);
            drawParticles(ctx);
            drawRainDrops(ctx);
            drawMagnetField(ctx);
            drawShield(ctx);
            ctx.restore();
        }
        function drawBackground(ctx) {
             const theme = GAME.currentTheme;
             const bgGrad = ctx.createLinearGradient(0, 0, 0, GAME.height);
             bgGrad.addColorStop(0, theme.bg[0]);
             bgGrad.addColorStop(1, theme.bg[1]);
             ctx.fillStyle = bgGrad;
             ctx.fillRect(0, 0, GAME.width, GAME.height);
             for (const star of backgroundStars) {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + star.speed * 0.4})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        function drawRainDrops(ctx) {
            ctx.strokeStyle = 'rgba(170, 190, 230, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (const drop of rainDrops) {
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 1, drop.y + drop.length);
            }
            ctx.stroke();
        }
        function drawTrack(ctx) {
             const theme = GAME.currentTheme;
            ctx.fillStyle = theme.track;
            ctx.fillRect(TRACK.x, 0, TRACK.width, GAME.height);
            const edgeGradL = ctx.createLinearGradient(TRACK.x - TRACK_CONFIG.EDGE_WIDTH, 0, TRACK.x, 0);
            edgeGradL.addColorStop(0, theme.edge); edgeGradL.addColorStop(1, theme.track);
            ctx.fillStyle = edgeGradL;
            ctx.fillRect(TRACK.x - TRACK_CONFIG.EDGE_WIDTH, 0, TRACK_CONFIG.EDGE_WIDTH, GAME.height);
            const edgeGradR = ctx.createLinearGradient(TRACK.x + TRACK.width, 0, TRACK.x + TRACK.width + TRACK_CONFIG.EDGE_WIDTH, 0);
            edgeGradR.addColorStop(0, theme.track); edgeGradR.addColorStop(1, theme.edge);
            ctx.fillStyle = edgeGradR;
            ctx.fillRect(TRACK.x + TRACK.width, 0, TRACK_CONFIG.EDGE_WIDTH, GAME.height);
            for (const line of TRACK.lines) {
                ctx.beginPath();
                ctx.moveTo(line.x + line.width/2, line.y);
                ctx.lineTo(line.x + line.width/2, line.y + line.height);
                ctx.lineWidth = line.width;
                ctx.strokeStyle = theme.line;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }
         function drawTireMarks(ctx) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            for (const mark of tireMarks) {
                const alpha = mark.life / CAR_CONFIG.TIRE_MARK_LIFE;
                ctx.globalAlpha = alpha * 0.6;
                ctx.beginPath();
                ctx.rect(mark.x - mark.width / 2, mark.y - mark.height / 2, mark.width, mark.height);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }
        function drawObstacles(ctx) {
            for (const obs of obstacles) {
                ctx.save();
                ctx.translate(obs.x, obs.y);
                ctx.rotate(obs.rotation);
                ctx.globalAlpha = obs.opacity || 1;
                const img = ASSETS.loaded[obs.imgKey];

                if (obs.fatal) {
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                     ctx.beginPath();
                     ctx.ellipse(0, obs.height * 0.55, obs.width * 0.45, obs.height * 0.15, 0, 0, Math.PI * 2);
                     ctx.fill();
                }

                if (obs.type === 'sweeper') {
                     ctx.fillStyle = obs.color;
                     ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                     ctx.fillStyle = 'yellow';
                     for (let i = -obs.width/2 + obs.width * 0.05; i < obs.width/2; i += obs.width * 0.2) {
                         ctx.beginPath();
                         ctx.moveTo(i, -obs.height/2);
                         ctx.lineTo(i + obs.width * 0.1, -obs.height/2);
                         ctx.lineTo(i + obs.width * 0.05, obs.height/2);
                         ctx.lineTo(i - obs.width * 0.05, obs.height/2);
                         ctx.closePath();
                         ctx.fill();
                     }
                } else if (obs.type === 'pothole') {
                     ctx.fillStyle = obs.color;
                     ctx.beginPath();
                     ctx.ellipse(0, 0, obs.width / 2, obs.height / 2, 0, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.strokeStyle = '#331a00';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.ellipse(0, 0, obs.width / 2 * 0.9, obs.height / 2 * 0.8, 0, 0, Math.PI * 2);
                     ctx.stroke();
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                     ctx.beginPath();
                     ctx.ellipse(0, 0, obs.width / 2 * 0.6, obs.height / 2 * 0.5, 0, 0, Math.PI * 2);
                     ctx.fill();
                }
                else if (img && img.complete && img.naturalHeight !== 0) {
                    ctx.drawImage(img, -obs.width / 2, -obs.height / 2, obs.width, obs.height);
                    if (obs.fatal && obs.y < GAME.height * 0.4 && obs.y > -obs.height * 2) {
                        const proximityFactor = 1 - Math.max(0, obs.y / (GAME.height * 0.4));
                        const glowIntensity = Math.abs(Math.sin(Date.now() / 150 + obs.x)) * proximityFactor;
                        ctx.shadowColor = `rgba(255, 0, 0, ${glowIntensity * 0.9})`;
                        ctx.shadowBlur = 15 + glowIntensity * 15;
                        ctx.drawImage(img, -obs.width / 2, -obs.height / 2, obs.width, obs.height);
                        ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                    }
                } else {
                    ctx.fillStyle = obs.color;
                    ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                     if (obs.type === 'oilSlick') {
                         ctx.fillStyle = 'rgba(255,255,255,0.1)';
                         for(let i=0; i<5; ++i) ctx.fillRect(-obs.width/2 + Math.random()*obs.width*0.8, -obs.height/2 + Math.random()*obs.height*0.8, obs.width*0.2, obs.height*0.2);
                     } else if (obs.fatal) {
                         ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.beginPath();
                         ctx.moveTo(-obs.width * 0.4, -obs.height * 0.4); ctx.lineTo(obs.width * 0.4, obs.height * 0.4);
                         ctx.moveTo(obs.width * 0.4, -obs.height * 0.4); ctx.lineTo(-obs.width * 0.4, obs.height * 0.4); ctx.stroke();
                     }
                }
                 ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }
        function drawPowerUps(ctx) {
            for (const pu of powerUps) {
                ctx.save();
                ctx.translate(pu.x, pu.y);
                const floatY = Math.sin(Date.now() / 250 + pu.x / 10) * 4;
                ctx.translate(0, floatY);
                ctx.rotate(pu.rotation);
                const pulseSize = 1 + 0.1 * Math.sin(pu.pulse);
                ctx.shadowColor = pu.glow || pu.color;
                ctx.shadowBlur = 20 * pulseSize;
                ctx.beginPath();
                ctx.arc(0, 0, (pu.width / 2) * pulseSize, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pu.width / 2 * pulseSize);
                gradient.addColorStop(0, pu.color); gradient.addColorStop(0.7, pu.color); gradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradient; ctx.fill();
                 ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1; ctx.stroke();
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                drawPowerUpIcon(ctx, pu.icon, pu.width * 0.6 * pulseSize);
                ctx.restore();
            }
        }
        function drawPowerUpIcon(ctx, iconType, size) {
            ctx.fillStyle = 'white'; ctx.strokeStyle = 'white';
            ctx.lineWidth = Math.max(1, size * 0.08);
            const s = size / 2;
            ctx.save(); ctx.beginPath();
            switch (iconType) {
                case 'shield': ctx.moveTo(0, -s); ctx.lineTo(s, -s*0.3); ctx.lineTo(s*0.6, s); ctx.lineTo(-s*0.6, s); ctx.lineTo(-s, -s*0.3); ctx.closePath(); ctx.fill(); break;
                case 'speed': ctx.moveTo(-s*0.6, -s*0.5); ctx.lineTo(-s*0.1, -s*0.5); ctx.lineTo(s*0.4, 0); ctx.lineTo(-s*0.1, s*0.5); ctx.lineTo(-s*0.6, s*0.5); ctx.lineTo(-s*0.1, 0); ctx.closePath(); ctx.moveTo(0, -s*0.5); ctx.lineTo(s*0.5, -s*0.5); ctx.lineTo(s, 0); ctx.lineTo(s*0.5, s*0.5); ctx.lineTo(0, s*0.5); ctx.lineTo(s*0.5, 0); ctx.closePath(); ctx.fill(); break;
                case 'score': ctx.moveTo(0, -s); for (let i = 1; i < 5; i++) { const a = i * Math.PI * 0.8; ctx.lineTo(Math.sin(a) * s, -Math.cos(a) * s); } ctx.closePath(); ctx.fill(); break;
                case 'life': ctx.moveTo(0, s * 0.3); ctx.bezierCurveTo(s * 0.7, -s * 0.2, s * 1.1, -s * 0.8, 0, -s * 0.4); ctx.bezierCurveTo(-s * 1.1, -s * 0.8, -s * 0.7, -s * 0.2, 0, s * 0.3); ctx.fill(); break;
                case 'magnet': ctx.lineWidth = s * 0.4; ctx.arc(0, s*0.1, s * 0.6, Math.PI * 1.15, Math.PI * -0.15); ctx.stroke(); ctx.fillStyle = '#e5e5e5'; ctx.fillRect(-s, -s*0.1, s*0.4, s*0.5); ctx.fillRect(s*0.6, -s*0.1, s*0.4, s*0.5); break;
                case 'clear': for (let i = 0; i < 8; i++) { const a = (i / 8) * Math.PI * 2; ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*s*0.6, Math.sin(a)*s*0.6); ctx.lineTo(Math.cos(a)*s, Math.sin(a)*s); } ctx.lineWidth = s*0.15; ctx.lineCap = 'round'; ctx.stroke(); break;
                case 'slowmo':
                    ctx.arc(0, 0, s, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#555';
                    ctx.fillRect(-s * 0.1, -s * 0.5, s * 0.2, s * 0.6);
                    ctx.fillRect(-s * 0.4, -s * 0.1, s * 0.5, s * 0.2);
                    break;
            }
            ctx.restore();
        }
        function drawCar(ctx) {
            ctx.save();
            ctx.translate(CAR.x, CAR.y);
            if (oilSlickTimer > 0) {
                const wobbleAngle = Math.sin(Date.now() / 50) * 0.1; ctx.rotate(wobbleAngle);
            } else if (GAME.potholeTimer > 0) {
                 const tiltAngle = Math.sin(Date.now() / 80) * 0.05; ctx.rotate(tiltAngle);
            } else {
                 const turnRatio = (CAR.targetX - CAR.x) / (CAR.width * 1.5); ctx.rotate(turnRatio * -0.15);
            }
            if (CAR.invincibilityTimer > 0) {
                ctx.globalAlpha = (Math.floor(CAR.invincibilityTimer / 4) % 2 === 0) ? 1.0 : 0.3;
            }
            const img = ASSETS.loaded.car;
             if (img && img.complete && img.naturalHeight !== 0) {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.beginPath(); ctx.ellipse(0, CAR.height * 0.5, CAR.width * 0.4, CAR.height * 0.1, 0, 0, Math.PI * 2); ctx.fill();
                 ctx.drawImage(img, -CAR.width / 2, -CAR.height / 2, CAR.width, CAR.height);
            } else {
                ctx.fillStyle = '#39f'; ctx.fillRect(-CAR.width / 2, -CAR.height / 2, CAR.width, CAR.height);
                 ctx.fillStyle = '#222'; ctx.fillRect(-CAR.width*0.3, -CAR.height*0.3, CAR.width*0.6, CAR.height*0.4);
                 ctx.fillStyle = '#ffdd00'; ctx.fillRect(-CAR.width*0.4, CAR.height*0.3, CAR.width*0.2, CAR.height*0.1); ctx.fillRect(CAR.width*0.2, CAR.height*0.3, CAR.width*0.2, CAR.height*0.1);
            }
            ctx.restore();
        }
        function drawShield(ctx) {
            if (!CAR.isShielded) return;
            ctx.save(); ctx.translate(CAR.x, CAR.y);
            const shieldRadius = Math.max(CAR.width, CAR.height) * 0.75;
            const shieldPulse = Math.sin(Date.now() / 180) * 0.05 + 1;
            const currentRadius = shieldRadius * shieldPulse;
            const timeRatio = Math.max(0, CAR.shieldTimer / POWERUP_TYPES.shield.duration);
            ctx.shadowColor = `rgba(0, 200, 255, ${0.5 + timeRatio * 0.4})`;
            ctx.shadowBlur = 15 + timeRatio * 10;
            const gradient = ctx.createRadialGradient(0, 0, currentRadius * 0.2, 0, 0, currentRadius);
            const alpha = Math.min(1, CAR.shieldTimer / 45);
            gradient.addColorStop(0, `rgba(0, 180, 255, ${0.1 * alpha})`); gradient.addColorStop(0.8, `rgba(0, 180, 255, ${0.3 * alpha})`); gradient.addColorStop(1, `rgba(0, 200, 255, ${0.6 * alpha})`);
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI * 2); ctx.fill();
             ctx.strokeStyle = `rgba(100, 220, 255, ${0.8 * alpha})`; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();
        }
         function drawMagnetField(ctx) {
            if (!CAR.hasMagnet) return;
            ctx.save(); ctx.translate(CAR.x, CAR.y);
            const radius = GAME_CONFIG.MAGNET_RADIUS;
            const pulse = Math.sin(Date.now() / 150) * 0.1 + 1;
            const alpha = Math.min(1, CAR.magnetTimer / 60) * 0.6;
            const rotation = (Date.now() / 1500) % (Math.PI * 2);
            ctx.strokeStyle = `rgba(204, 51, 255, ${alpha})`; ctx.lineWidth = 2; ctx.setLineDash([4, 8]);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + rotation;
                ctx.beginPath(); ctx.moveTo(Math.cos(angle) * CAR.width*0.4, Math.sin(angle) * CAR.width*0.4); ctx.lineTo(Math.cos(angle) * radius * pulse, Math.sin(angle) * radius * pulse); ctx.stroke();
            }
            ctx.setLineDash([]); ctx.restore();
        }
        function drawParticles(ctx) {
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) {
                 if (!p.isText) {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.alpha, 0, Math.PI * 2);
                    ctx.fill();
                 }
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            for (const p of particles) {
                 if (p.isText) {
                     ctx.globalAlpha = p.alpha;
                     ctx.font = `bold ${p.size}px Arial`;
                     ctx.fillStyle = p.color;
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     const yOffset = (1 - (p.life / p.maxLife)) * -20;
                     ctx.fillText(p.text, p.x, p.y + yOffset);
                 }
            }
            ctx.globalAlpha = 1.0;
        }
        function showScreen(screenName) {
            Object.values(DOM.screens).forEach(screen => screen.classList.add('hidden'));
            DOM.hud.container.classList.add('hidden');
            GAME.state = screenName;
            if (screenName === 'loading') DOM.screens.loading.classList.remove('hidden');
            else if (screenName === 'intro') { DOM.screens.intro.classList.remove('hidden'); updateIntroHighScore(); }
            else if (screenName === 'gameOver') DOM.screens.gameOver.classList.remove('hidden');
            else if (screenName === 'playing') DOM.hud.container.classList.remove('hidden');
        }
        function showLevelAlert() {
            DOM.levelNumber.textContent = GAME.level;
            DOM.levelAlert.classList.add('visible');
            levelAlertTimer = 120;
        }
        function updateHUD() {
            DOM.hud.score.textContent = GAME.score;
            DOM.hud.level.textContent = GAME.level;
        }
        function updateLivesDisplay(instant = false) {
            const container = DOM.hud.livesContainer;
            if (!container) return;
            const currentIcons = container.children.length;
            if (currentIcons > GAME.lives) {
                for (let i = currentIcons - 1; i >= GAME.lives; i--) {
                    const iconToRemove = container.children[i];
                    if (iconToRemove) {
                         if (instant) {
                             iconToRemove.remove();
                         } else {
                             iconToRemove.classList.add('lost');
                             setTimeout(() => iconToRemove.remove(), 350);
                             iconToRemove.addEventListener('transitionend', () => iconToRemove.remove(), { once: true });
                         }
                    }
                }
            }
            else if (currentIcons < GAME.lives) {
                for (let i = 0; i < GAME.lives - currentIcons; i++) {
                    const lifeIcon = document.createElement('div');
                    lifeIcon.className = 'life-icon';
                    container.appendChild(lifeIcon);
                     if (!instant) {
                         lifeIcon.style.transform = 'scale(0)';
                         lifeIcon.style.opacity = '0';
                         void lifeIcon.offsetWidth;
                         lifeIcon.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease-out';
                         lifeIcon.style.transform = 'scale(1)';
                         lifeIcon.style.opacity = '1';
                     }
                }
            }
        }
        function updatePowerupIndicators() {
             DOM.powerupIndicators.shield.classList.toggle('active', CAR.isShielded);
             DOM.powerupIndicators.speed.classList.toggle('active', CAR.speedBoostActive);
             DOM.powerupIndicators.magnet.classList.toggle('active', CAR.hasMagnet);
             DOM.powerupIndicators.slowmo.classList.toggle('active', GAME.isSlowMotionActive);
        }
        function handleKeyDown(e) {
            if (GAME.state !== 'playing') return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') CAR.isMovingLeft = true;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') CAR.isMovingRight = true;
        }
        function handleKeyUp(e) {
             if (GAME.state !== 'playing') return;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') CAR.isMovingLeft = false;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') CAR.isMovingRight = false;
        }
        let touchStartX = null; let touchCurrentX = null; let touchTargetX = null;
        function handleTouchStart(e) {
            if (GAME.state !== 'playing' || e.touches.length === 0) return;
            e.preventDefault();
            const touchXInCanvas = e.touches[0].clientX - GAME.canvas.getBoundingClientRect().left;
            const gameTouchX = touchXInCanvas / GAME.scaleFactor;
            touchTargetX = gameTouchX;
             if (touchTargetX < CAR.x) { CAR.isMovingLeft = true; CAR.isMovingRight = false; }
             else { CAR.isMovingRight = true; CAR.isMovingLeft = false; }
        }
        function handleTouchMove(e) {
            if (GAME.state !== 'playing' || e.touches.length === 0) return;
            e.preventDefault();
             const touchXInCanvas = e.touches[0].clientX - GAME.canvas.getBoundingClientRect().left;
             const gameTouchX = touchXInCanvas / GAME.scaleFactor;
            touchTargetX = gameTouchX;
            CAR.targetX = touchTargetX;
             if (CAR.targetX < CAR.x - 1) { CAR.isMovingLeft = true; CAR.isMovingRight = false; }
             else if (CAR.targetX > CAR.x + 1) { CAR.isMovingRight = true; CAR.isMovingLeft = false; }
             else { CAR.isMovingLeft = false; CAR.isMovingRight = false; }
        }
        function handleTouchEnd(e) {
            if (GAME.state !== 'playing') return;
            CAR.isMovingLeft = false; CAR.isMovingRight = false;
            touchStartX = null; touchCurrentX = null;
        }
        function createParticles(x, y, count, color, baseSize = 3, speed = 3, life = 45, isExhaust = false) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const particleSpeed = 1 + Math.random() * speed;
                const size = Math.random() * baseSize + 1;
                const maxLife = life + Math.random() * (life * 0.5);
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * particleSpeed,
                    vy: Math.sin(angle) * particleSpeed - (isExhaust ? 0 : Math.random() * 1.5),
                    size: size,
                    color: color,
                    life: maxLife, maxLife: maxLife, alpha: 1.0,
                    isExhaust: isExhaust
                });
            }
             if (particles.length > 300) particles.splice(0, particles.length - 300);
        }
        function resizeGame() {
            const container = DOM.container;
            const aspectRatio = GAME_CONFIG.BASE_WIDTH / GAME_CONFIG.BASE_HEIGHT;
            const availWidth = window.visualViewport?.width ?? window.innerWidth;
            const availHeight = window.visualViewport?.height ?? window.innerHeight;
            const windowRatio = availWidth / availHeight;
            let newWidth, newHeight;
            if (windowRatio > aspectRatio) { newHeight = availHeight; newWidth = newHeight * aspectRatio; }
            else { newWidth = availWidth; newHeight = newWidth / aspectRatio; }
             newWidth = Math.max(200, newWidth); newHeight = Math.max(150, newHeight);
            container.style.width = `${newWidth}px`; container.style.height = `${newHeight}px`;
            GAME.canvas.width = GAME_CONFIG.BASE_WIDTH; GAME.canvas.height = GAME_CONFIG.BASE_HEIGHT;
            GAME.scaleFactor = newWidth / GAME_CONFIG.BASE_WIDTH;
            GAME.width = GAME_CONFIG.BASE_WIDTH; GAME.height = GAME_CONFIG.BASE_HEIGHT;
            updateElementSizes();
            createTrackLayout();
            const carYPosition = GAME.height - CAR.height * 1.0;
            if (GAME.state !== 'loading' && GAME.state !== 'intro') {
                 const carHalfWidth = CAR.width * CAR_CONFIG.HITBOX_SCALE.width / 2;
                 const minX = TRACK.x + carHalfWidth; const maxX = TRACK.x + TRACK.width - carHalfWidth;
                 CAR.x = Math.max(minX, Math.min(maxX, CAR.x));
                 CAR.targetX = CAR.x;
                 CAR.y = carYPosition;
            } else {
                 CAR.x = TRACK.x + TRACK.width / 2; CAR.targetX = CAR.x; CAR.y = carYPosition;
            }
            createBackgroundStars();
            createRainDrops();
        }
        function updateElementSizes() {
            TRACK.width = GAME.width * TRACK_CONFIG.WIDTH_RATIO; TRACK.x = (GAME.width - TRACK.width) / 2;
            TRACK.lineWidth = Math.max(1, TRACK.width * TRACK_CONFIG.LINE_WIDTH_RATIO);
            TRACK.lineHeight = GAME.height * TRACK_CONFIG.LINE_HEIGHT_RATIO; TRACK.lineGap = GAME.height * TRACK_CONFIG.LINE_GAP_RATIO;
            CAR.width = GAME.width * CAR_CONFIG.WIDTH_RATIO; CAR.height = GAME.height * CAR_CONFIG.HEIGHT_RATIO;
            CAR.lateralSpeed = GAME.width * CAR_CONFIG.LATERAL_SPEED_RATIO;
        }
        function createTrackLayout() {
            TRACK.lines = [];
            const lineCount = Math.ceil(GAME.height / (TRACK.lineHeight + TRACK.lineGap)) + 2;
            for (let i = 0; i < lineCount; i++) {
                TRACK.lines.push({
                    x: TRACK.x + (TRACK.width / 2) - (TRACK.lineWidth / 2),
                    y: (i * (TRACK.lineHeight + TRACK.lineGap)) - (TRACK.lineHeight + TRACK.lineGap),
                    width: TRACK.lineWidth, height: TRACK.lineHeight
                });
            }
        }
        window.addEventListener('load', init);
    })();
    </script>
